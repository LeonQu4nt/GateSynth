function [K0,K1,H] = Cartan(G,l_space,m_space,h_space)
%Cartan Performs the Cartan decomposition of matrix G
%   This function takes an arbitrary element of SU(2^n) and decomposes it
%   using the subspaces l_space, m_space and h_space. These are provided as
%   lists of matrices that represent the basis of su(2^n). Example
%   subspaces are provided by suGen.m script.

% Step 1: Declare global variables and initialise subspaces from file
% suGen.m
suGen;
global g;
global g_m;
global g_l;
global basis_m;
global basis_l;
global m;
global v;
global K_min;
basis_m = m_space;
basis_l = l_space;
G = G/expm(1i*angle(G(1,1)));
g = logm(G);    %g is the generator in su(2^n) of G.
g_l = 0;    %g_l and g_m are the components of g along the subspaces l_space and m_space
g_m = 0;

%Step 2: Separate g into its components along the 2 subspaces
for j = 1:size(l_space,3)
    g_l = g_l+trace(g'*basis_l(:,:,j))/trace(basis_l(:,:,j)'*basis_l(:,:,j))*basis_l(:,:,j);
end

for j = 1:size(m_space,3)
    g_m = g_m+trace(g'*basis_m(:,:,j))/trace(basis_m(:,:,j)'*basis_m(:,:,j))*basis_m(:,:,j);
end

lim = 10^6;
eps1 = inf;
m = g_m;
num = 0;

%Iterative method for estimating starting point
while eps1 > 0.15 && num < lim
    num = num+1;
    k = PolQ(m);
    G_trial = expm(k)*expm(m);
    G_actual = expm(g_l+g_m);
    for i = 1:length(G_trial);
        if abs(G_trial(i,1))>0.1
            break
        end
    end
    G_trial = G_trial/exp(1i*angle(G_trial(i,1)));
    G_actual = G_actual/exp(1i*angle(G_actual(i,1)));
    eps1 = sum(sum(abs(G_actual-G_trial)));
    
    m = logm(expm(-k)*expm(g_m+g_l));
    
    m_m = 0;
for j = 1:size(basis_m,3)
    m_m = m_m+real(trace(m'*basis_m(:,:,j)))/trace(basis_m(:,:,j)'*basis_m(:,:,j))*basis_m(:,:,j)+real(trace(m))/length(m)*eye(size(m));
end
    m = m_m;

end

init_mat = m;

% Step 6: find minimum of map function to find components

init_pos = to_vect(init_mat,basis_m);
options = optimoptions('fsolve','Algorithm','levenberg-marquardt','MaxFunctionEvaluations',3e5,'OptimalityTolerance',1e-4,'TolX',1e-50,'TypicalX',1*ones(size(basis_m,3),1));
m_vect = fsolve(@map,init_pos,options);

m = 0;

for k = 1:size(basis_m,3)
    m = m + m_vect(k)*basis_m(:,:,k);
end

K0 = G*expm(-m);

% Step 8: Compute vector v
v = 0;
for k = 1:size(h_space,3)
    v = v + (pi/2)^(k-1)*h_space(:,:,k);
end

% Step 9: Minimize function f_vm to find optimum v
K_init = zeros(size(basis_l,3),1);
options = optimset('MaxIter',4000,'TolX',1e-30,'TolFun',1e-10,'MaxFunEvals',1e6,'TypicalX',1e-3*ones(size(basis_l,3),1));
K_min = fminunc(@f_vm, K_init, options); 

K1_gen = 0;
for k = 1:size(basis_l,3)
    K1_gen = K1_gen + K_min(k)*basis_l(:,:,k);
end

K1 = expm(K1_gen);

% Step 10: Compute central matrix H generated by h_space Abelian subspace
h = K1'*m*K1;
H = expm(h);
end

